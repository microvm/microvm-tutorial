===============
Getting Started
===============

Where is Everything?
====================

The `specification <https://github.com/microvm/microvm-spec/wiki>`__ is the
canonical source of information about the implementation-neutral parts of Mu.

This tutorial will use the `reference implementation
<https://github.com/microvm/microvm-refimpl2>`__. Keep in mind that it is not
high-performance. It is interpreted and single-threaded, does excessive checking
and is very slow.

The current Mu reference implementation is written in Scala and runs on JVM
1.8 (tested on HotSpot). If you are not familiar with Scala, `this list
<http://www.scala-lang.org/documentation/books.html>`__ provides useful
resources and some books are freely available online.

Get Mu
======

Please follow the instructions in the `README
<https://github.com/microvm/microvm-refimpl2/blob/master/README.md>`__ file in
the ``microvm-refimpl2`` repository to install building tools, clone the
repository and build it.

It is recommended to use `ScalaIDE <http://scala-ide.org/>`__. It is the Eclipse
IDE with Scala plugins pre-installed. If you use IntelliJ IDEA, you may notice
that it rejects some correct Scala programs and accepts some Scala code with
syntax/semantic errors.

The microvm-refimpl2 depends on Antlr4 to generate a parser. Make sure you
follow the instructions in the README file to generate extra source files and
let your IDE know their presence.

Run Some Tests
==============

There are some test suites in the ``src/test/scala`` directory (e.g.
``src/test/scala/uvm/refimpl/itpr/UvmInterpreterSpec.scala``). You can run them
using your favourite tool (e.g. the Eclipse IDE) to see if Mu works correctly.
If it does, there should be no fails or errors.

Write Your Own Program
======================

As the ``microvm-refimpl2`` project is an experimental project, it is currently
not as well-modularised as other mature Scala/sbt or Java/Maven projects. The
recommended way to add your own code is to create some entry points in the
``src/test/scala`` directory. If you don't want to commit your changes to the
``master`` branch of the Git repository, you can create a different branch and
merge (or rebase) from the ``master`` branch from time to time.

Now create a new git branch (you may do it within Eclipse, too)::

    git checkout -b my-tutorial-junks

Create a Scala source file ``src/test/scala/tutorial/HelloUvm.scala``:

.. literalinclude:: code/HelloUvm.scala
    :language: scala
    :linenos:

Then run this object. In Eclipse, you can right-click on the object name and
select Run As -> Scala Application.

It should print nothing except several lines of DEBUG logs.

The centre of a Mu instance is an instance of the ``uvm.refimpl.MicroVM`` class.
It and its related objects maintain the states of Mu (for example, memory,
threads, stacks, loaded code and so on). Currently there is no way to "close" a
Mu instance. Simply quitting the program will be fine.

A *client agent* is an object that helps the client communicate with Mu.  All
actions that the client can do to manipulate the state of Mu are done via a
client agent. Since client agents may hold resources for the client (for
example, references to memory objects), it must be explicitly closed.

The unit of code delivery from the client to Mu is *bundle*. The bundle has a
text format and a binary format, but this reference implementation only
implements the text format. There are many bundles in the ``tests`` directory.
In a realistic scenario, bundles will be generated by a high-level JIT compiler
in the client rather than loaded from pre-written files in the file system.
Bundles are loaded into Mu via client agents.

In the following chapters, the *Mu intermediate representation*, that is, the
code written in the bundles, will be introduced. One way to check if your code
is correct is to load it into Mu.

.. vim: tw=80
